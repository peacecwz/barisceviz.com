import MarkdownWrapper from "../../components/MarkdownWrapper";

<MarkdownWrapper title="Installing MicroPython on the ESP32 (macOS)">


# .NET Core Hosted Service ile Azure Service Bus KullanÄ±mÄ±

![alt text](https://miro.medium.com/max/2732/0*Oo-sqLT89ulFCem8.png ".NET Core Hosted Service ile Azure Service Bus KullanÄ±mÄ±")

Bu yazÄ±mÄ±zda .NET Core iÃ§erisinde gelen HostedServices ile Azure Service Bus Ã¼rÃ¼nÃ¼ nasÄ±l konuÅŸur ve Producer & Consumer konularÄ±nÄ± konuÅŸacaÄŸÄ±z.

## Azure Service Bus

Microsoft Azure Ã¼zerinde PaaS olarak sunulan scalable bir messaging Ã¼rÃ¼nÃ¼dÃ¼r. Event Driven Architecture gibi konularda sÄ±k tercih edilen bu messaging Ã¼rÃ¼nlerinden Cloud Vendor Ã¼zerinde sunulan bir servistir. Azure Ã¼zerinde RabbitMQ ve Apache Kafka da sunulmaktadÄ±r fakat bu diÄŸer iki Ã¼rÃ¼n arasÄ±ndaki en bÃ¼yÃ¼k fark, infrastructure maliyetleri, maintenance gibi operasyonel sÃ¼reÃ§lerden kurtulup sadece scale ettiÄŸiniz ve infrastructure Ä± dÃ¼ÅŸÃ¼nmeden Ã§alÄ±ÅŸabilmenizi saÄŸlamaktadÄ±r.

![alt text](https://miro.medium.com/max/1380/1*8_gDdy9l3xk32FUA_LaRXQ.png ".NET Core Hosted Service ile Azure Service Bus KullanÄ±mÄ±")

En temel fiyatlandÄ±rma yukarÄ±daki gÃ¶rdÃ¼ÄŸÃ¼nÃ¼z tablo ile aÃ§Ä±klanabilir. Bu fiyatlar West Europe fiyatlarÄ±dÄ±r. Bu fiyatlandÄ±rmalarÄ± daha detaylandÄ±rmak ve incelemk isterseniz Azure Calculator Ã¼zerinden fiyatlandÄ±rmalarÄ±nÄ±zÄ± hesaplayabilirsiniz

### Azure Service Bus OluÅŸturma

Azure Service Bus oluÅŸturmanÄ±z iÃ§in en temel ihtiyaÃ§lardan bir tanesi Azure Ã¼zerinde geÃ§erli bir aboneliÄŸinizin olmasÄ± gerekmektedir.

Azure Portal Ã¼zerinden Create a Resource > Integration > Service Bus seÃ§erek oluÅŸturma ekranÄ±na girelim.

Buradaki en Ã§ok dikkat etmemiz gereken nokta Pricing tarafÄ±dÄ±r. Azure, Ã¶neri olarak Premium sunmaktadÄ±r fakat buradaki ihtiyacÄ±nÄ±zÄ± belirleyerek ilgili tier Ä± seÃ§meniz daha doÄŸru olacaktÄ±r.

![alt text](https://miro.medium.com/max/858/1*1EnXyjvvyROqPOstr0EMgQ.png ".NET Core Hosted Service ile Azure Service Bus KullanÄ±mÄ±")

Buradaki Standard ve Premium tier larÄ± arasÄ±nda en Ã¶nemli farklardan birisi resource un dedicated veya shared ortamlarda sunulmasÄ±dÄ±r. Dedicated ortam daha performanslÄ± ama maliyeti yÃ¼ksek olacaktÄ±r. YÃ¼ksek seviyede yÃ¼k sahibi iseniz Premium mantÄ±klÄ±dÄ±r. Standard ile Basic arasÄ±nda ise en bÃ¼yÃ¼k farklÄ±lÄ±klardan birisi topic kavramÄ± Standard ve sonraki tierlar Ã¼zerinde gelmektedir. Bu yÃ¼zden orta Ã¶lÃ§ekli uygulamalar iÃ§in Standard paketini seÃ§mekteyim.

Standard to Premium migration iÃ§in safe bir geÃ§iÅŸ saÄŸlamaktadÄ±r. Post-Migration ile tÃ¼m trafiÄŸinizi Premium Service Bus Ã¼zerine aldÄ±ÄŸÄ±nÄ±zda artÄ±k Standard paketi kullanmadan devam edebilirsiniz. AslÄ±nda migration sÃ¼recinde iki farklÄ± resource oluÅŸturup aralarÄ±nda post-migration saÄŸlamaktadÄ±r.

![alt text](https://miro.medium.com/max/1400/1*_RnbpmIvtwozjE9rtBGBqw.png ".NET Core Hosted Service ile Azure Service Bus KullanÄ±mÄ±")

YukarÄ±daki ekran gÃ¶rÃ¼ntÃ¼sÃ¼ndeki gibi resource ve location seÃ§imlerimi yapÄ±yorum ve oluÅŸturuyorum.

![alt text](https://miro.medium.com/max/522/1*VHt6fHwW2AYOPpgVi7O6ug.png ".NET Core Hosted Service ile Azure Service Bus KullanÄ±mÄ±")

Service Bus resource unu oluÅŸturduÄŸumuza gÃ¶re artÄ±k Queue ve Topics arasÄ±ndaki farkÄ± konuÅŸabiliriz. Bu yazÄ±mda Ã§ok darlamak istemiyorum fakat en temel farkÄ±nÄ± Ã§ok basitÃ§e ve Ã¶rnekle aktaracaÄŸÄ±m

Queue Ã¼zerinde bir mesajÄ± bir consumer (tÃ¼keten) kullanabilirken, topics Ã¼zerinden geÃ§en bir mesajÄ± birden fazla consumer kullanabilmektedir.

Ã–rneÄŸin; Ã¼rÃ¼n oluÅŸturduÄŸuna dair bir mesaj gÃ¶nderiyorsunuz ve bu mesaj atÄ±ldÄ±ktan sonra SMS, Email, Teslimat paketi oluÅŸturma iÅŸlemlerini yapÄ±yorsunuz ve bunu paralel olarak yapmak istiyorsunuz diyelim. Bu noktada Topics kullanmanÄ±z gerekmektedir. Siz mesajÄ± verdiÄŸiniz zaman bu mesaj, SMS iÃ§in ayrÄ±, Email iÃ§in ayrÄ± ve Teslimat paketi iÃ§in ayrÄ± kullanÄ±lacak ve paralel olarak Ã§alÄ±ÅŸabilecektir.

## .NET Core & ServiceBus ile Consumer Projesi oluÅŸturma

BoÅŸ console application oluÅŸturalÄ±m ve iÃ§erisine birkaÃ§ package kurarak hazÄ±rlayalÄ±m.

```csharp
    dotnet new console -n ServiceBusExample
```

ArdÄ±ndan proje iÃ§erisine girelim ve aÅŸaÄŸÄ±daki iki Ã¶nemli paketi kuralÄ±m

```csharp
    dotnet add package Microsoft.Extensions.Hosting
```

Bu paket HostedServices ve Dependency Injectionâ€™Ä± configure edebilmenizi saÄŸlamasÄ± aÃ§Ä±sÄ±ndan hazÄ±rlanmÄ±ÅŸ bir pakettir.

```csharp
    dotnet add package Microsoft.Azure.ServiceBus
```

Bu paket ise Azure ServiceBus integration saÄŸlamanÄ±z iÃ§in gereken Client library package Ä±dÄ±r.

GeliÅŸtireceÄŸimiz Consumer projesinde configuration larÄ±mÄ±zÄ± CommandLine Arguments veya Environment Variables olarak alacaÄŸÄ±m. Ä°sterseniz JsonFileConfiguration ekleyebilirsiniz. Configuration iÃ§in Program.cs iÃ§erisinde basit bir configure method u yazalÄ±m

```cs
    private static void ConfigureHostConfiguration(IConfigurationBuilder builder)
    {
        builder
            .AddEnvironmentVariables()
            .AddCommandLine(Arguments);
    }
```

Burada Arguments olarak belirttiÄŸimiz aslÄ±nda Main methodunda gelen args parametresidir. Bu parametreyi class iÃ§erisine taÅŸÄ±yalÄ±m

```cs
    private static string[] Arguments { get; set; }

    static void Main (string[] args) {
        Arguments = args;

        Console.WriteLine ("Hello World!");
    }
```

BÃ¶ylelikle Configuration methodu artÄ±k Arguments a eriÅŸebilir. Host umuzu basitÃ§e ayaÄŸa kaldÄ±ralmanÄ±n vakti geldi. DefaultHostBuilder ile basit bir host build edeceÄŸiz ve onu Ã§alÄ±ÅŸtÄ±racaÄŸÄ±z. Host kapanana kadar uygulamamÄ±z Ã§alÄ±ÅŸacaktÄ±r. BÃ¶ylelikle Kubernetes Ã¼zerinde rahatlÄ±kla Ã§alÄ±ÅŸtÄ±rabilir ve consumer projelerinizi ayaklandÄ±rabilirsiniz.

```cs
    static async Task Main(string[] args)
    {
        Arguments = args;

        var host = Host.CreateDefaultBuilder(args)
        .ConfigureHostConfiguration(ConfigureHostConfiguration)
        .Build();

        await host.RunAsync();
    }
```

Host async olarak run edilebilidiÄŸi iÃ§in burada Main methodumuzu async olarak Ã§alÄ±ÅŸtÄ±rmaya baÅŸladÄ±k. YazdÄ±ÄŸÄ±mzÄ± Configure methodunu Host Configuration Ä± olarak verdik ve artÄ±k Command-line ve Environment Variables olarak configleri alabiliriz.

ArtÄ±k HostedService oluÅŸturmamÄ±zÄ±n vakti geldi ğŸ‰ğŸ‰ Bir host iÃ§erisine birden fazla HostedService yerleÅŸtirebilirsiniz ve bu HostedServices lar Ã¼zerinde Dependency Injection uygulayabilirsiniz. ConsumerHostedService adÄ±nda bir class oluÅŸturalÄ±m ve bunu HostedService olarak initialize etmeye baÅŸlayalÄ±m.

```cs
    public class ConsumerhostedService : IHostedService, IDisposable
    {
        public Task StartAsync(CancellationToken cancellationToken)
        {
            Console.WriteLine("Started Hosted Service");

            return Task.CompletedTask;
        }

        public Task StopAsync(CancellationToken cancellationToken)
        {
            Console.WriteLine("Stopping Hosted Service");

            return Task.CompletedTask;
        }

        public void Dispose()
        {
            Console.WriteLine("Dispossing...");
        }
    }
```

Disposable bir hosted service yarattÄ±ÄŸÄ±mÄ±z zaman en temelde implement etmemiz gereken methodlar bu ÅŸekildedir. Start ve Stop bÃ¶lÃ¼mÃ¼nde connection kurduÄŸumuz external service leri open ve close edebiliriz. Dispose methodunda ise artÄ±k bu objeleri GCâ€™ye teslim edebiliriz.

StartAsync ve StopAsync ile gelen CancellationToken lar Ã¶nemlidir. Buradaki cancellationToken larÄ± aÃ§acaÄŸÄ±nÄ±z connection veya thread lere vermenizi tavsiye ederim. HostedService durdurulduÄŸunda bÃ¶ylelikle o anda gerÃ§ekleÅŸen process i de CancellationToken sayesinde durdurabilirsiniz. BÃ¶ylelikle uygulamanÄ±zÄ± saÄŸlÄ±klÄ± bir ÅŸekilde devam ettirmiÅŸ olur veya HostedService kapatÄ±ldÄ±ÄŸÄ±nÄ± anladÄ±ÄŸÄ±nzÄ±da yapmanÄ±z gereken son iÅŸlemleri gerÃ§ekleÅŸtirip, uygulamanÄ±zÄ±n kapanmasÄ±nÄ± saÄŸlayabilirsiniz.

```cs

    private static void ConfigureServices(HostBuilderContext hostBuilderContext,
        IServiceCollection serviceCollection)
    {
        serviceCollection.AddHostedService<ConsumerhostedService>();
    }
```

OluÅŸturduÄŸumuz HostedService i Program.cs iÃ§erisinde ConfigureService methodu oluÅŸturarak Dependency Injection a eklemek adÄ±na hazÄ±rlayalÄ±m. ArdÄ±ndan bu methodumuzu HostBuilder iÃ§erisine verelim ve Hostâ€™u bu service ler ile birlikte oluÅŸturmaya baÅŸlasÄ±n.

```cs
    static async Task Main(string[] args)
    {
        Arguments = args;

        var host = Host.CreateDefaultBuilder(args)
        .ConfigureHostConfiguration(ConfigureHostConfiguration)
        .ConfigureServices(ConfigureServices) // Add ConfigureServices method to Host
        .Build();

        await host.RunAsync();
    }
```

UygulamamÄ±zÄ± Ã§alÄ±ÅŸtÄ±rdÄ±ÄŸÄ±mÄ±zda gÃ¶rdÃ¼ÄŸÃ¼mÃ¼z gibi HostedService imiz Ã§alÄ±ÅŸmaktadÄ±r.

![alt text](https://miro.medium.com/max/994/1*ZYw-UScbDYQkxRLfnCTXyw.png ".NET Core Hosted Service ile Azure Service Bus KullanÄ±mÄ±")

Durdurmak istediÄŸimizde ise gÃ¶rdÃ¼ÄŸÃ¼nÃ¼z gibi kill etme sÃ¼reci de bu ÅŸekilde iÅŸlemektedir.

![alt text](https://miro.medium.com/max/976/1*sfTLISBoW-8CNxsWrrWb9Q.png ".NET Core Hosted Service ile Azure Service Bus KullanÄ±mÄ±")

BunlarÄ± tamamladÄ±ÄŸÄ±mÄ±za gÃ¶re artÄ±k ServiceBus Integration iÅŸlemlerimize geÃ§ebiliriz. Bu aÅŸamalarda ServiceBus Ã¼zerinde Queue oluÅŸturduÄŸumuzu varsayarak geliÅŸtireceÄŸiz. Son aÅŸamada ServiceBus Ã¼zerinde Queue oluÅŸturup aldÄ±ÄŸÄ±mÄ±z ConnectionString i uygulamamÄ±za verip Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± gÃ¶receÄŸiz

### Service Bus Integration

ConfigureServices methodumuzda ServiceBus iÃ§in QueueClient initialize edelim ve IoC iÃ§erisine register edelim. ArdÄ±ndan da HostedService iÃ§erisine inject ederek consumer Ä±mÄ±zÄ±n son aÅŸamasÄ±nÄ± hazÄ±rlayalÄ±m.

Bu method iÃ§erisinde configuration Ã¼zerinden gelen ServiceBusConnectionString ve ServiceBusQueueName adÄ±nda iki tane config alacaÄŸÄ±z ve bunlarla QueueClient Ä± initialize edeceÄŸiz

```cs
    private static void ConfigureServices(HostBuilderContext hostBuilderContext,
        IServiceCollection serviceCollection)
    {
        var configuration = hostBuilderContext.Configuration;

        string connectionString = configuration.GetValue<string>("ServiceBusConnectionString");
        string queueName = configuration.GetValue<string>("ServiceBusQueueName");

        if (string.IsNullOrEmpty(connectionString))
        {
            throw new ArgumentException("Service Bus Connection String cannot be null.");
        }

        if (string.IsNullOrEmpty(queueName))
        {
            throw new ArgumentException("Service Bus Queue Name cannot be null.");
        }

        var queueClient = new QueueClient(connectionString, queueName);

        serviceCollection.AddLogging();

        serviceCollection.AddSingleton<IQueueClient>(queueClient);
        serviceCollection.AddHostedService<ConsumerhostedService>();
    }
```

Burada configler boÅŸ gelirse uygulamamÄ±zÄ± direkt patlatÄ±yoruz ve devam etmesini engelliyoruz. Bu configler bizim iÃ§in required seviyesindedir. Configler dÃ¼zgÃ¼n geldiÄŸinde artÄ±k QueueClient Ä± initialize edip, IQueueClient ile IoC mize register edebiliriz. AynÄ± zamanda Logging iÃ§inde AddLogging diyerek IoC iÃ§erisine register edelim. Console iÃ§erisine loglama yapabilmemiz iÃ§in ihtiyacÄ±mÄ±z olacaktÄ±r.

```cs
    private readonly IQueueClient _queueClient;
    private readonly ILogger<ConsumerhostedService> _logger;

    public ConsumerhostedService(IQueueClient queueClient,
        ILogger<ConsumerhostedService> logger)
    {
            _queueClient = queueClient;
            _logger = logger;
    }
```

ConsumerHostedService iÃ§erisinde QueueClient ve Logger Ä± inject edelim. ArdÄ±ndan Queue binding operasyonlarÄ±mÄ±zÄ± yapalÄ±m

```cs
        public Task StartAsync(CancellationToken cancellationToken)
        {
            var messageHandlerOptions = new MessageHandlerOptions(e =>
            {
                OnError(e.Exception);
                return Task.CompletedTask;
            })
            {
                MaxConcurrentCalls = 3,
                AutoComplete = false
            };

            _queueClient.RegisterMessageHandler(OnProcess, messageHandlerOptions);
            _logger.LogInformation("Registered to ServiceBus");

            return Task.CompletedTask;
        }

        private Task OnProcess(Message message, CancellationToken cancellationToken)
        {
            return Task.CompletedTask;
        }

        private void OnError(Exception exception)
        {
            _logger.LogError($"Get exception on processing queue {exception.Message}", exception);
        }
```

StartAsync iÃ§erisinde Queue Ã¼zerinde gelecek Message larÄ± handle edebilmemiz iÃ§in OnProcess adÄ±nda bir methodumuzu register ediyoruz. Queue iÃ§erisine eklenen her mesajda OnProcess methodu tetiklenecektir. MessageHnadlerOptions Ã¼zerinde Concurrent iÅŸlenebilecek mesaj sayÄ±sÄ±nÄ±, iÅŸlenen mesajlarÄ±n otomatik silinmesi gibi ayarlarÄ± yapabiliyorsunuz. Ben AutoComplete Ã¶zelliÄŸini kapatÄ±yorum. Bunun sebebi, olasÄ± aldÄ±ÄŸÄ±m hatalarda tekrarlayabilmek adÄ±nadÄ±r. EÄŸer bÃ¶yle bir ihtiyacÄ±nÄ±z yok ise AutoComplete i true olarak ayarlayabilir ve mesajlarÄ±nÄ±z exception almadÄ±ÄŸÄ± sÃ¼rece Queue Ã¼zerinden dÃ¼ÅŸmeyecektir.

Hata alma durumunda aldÄ±ÄŸÄ± exception Ä± OnError adÄ±nda bir method a gÃ¶nderelim. ArdÄ±ndan bu method basit bir loglama iÅŸlemi gerÃ§ekleÅŸtirsin. Burada custom logicler yazabilirsiniz. Ã–rneÄŸin bir mesajÄ± 3 kez iÅŸlemeyi denesin, eÄŸer 3 den fazla hata alÄ±rsa bu mesajÄ± queue dan silsin gibi retry mekanizmalarÄ± yaratabilirsiniz

```cs
        public async Task StopAsync(CancellationToken cancellationToken)
        {
            await _queueClient.CloseAsync();
        }
```

StopAsync iÃ§erisinde QueueClient Ä± stop ederek artÄ±k consume etmesini kapatabiliriz.

```cs
        private Task OnProcess(Message message, CancellationToken cancellationToken)
        {
            var json = Encoding.UTF8.GetString(message.Body);
            _logger.LogInformation($"Queue Message: {json}");

            var data = JsonSerializer.Deserialize<object>(json);

            // Your custom logics here ...

            return Task.CompletedTask;
        }
```

OnProcess iÃ§erisinde gelen message byte array olarak gelmektedir. Bu gelen byte array i JSON string e Ã§evirip ardÄ±ndan Deserialize edebilirsiniz. Buradaki kritik nokta ise eÄŸer yÃ¼ksek boyutlarda mesajlar geliyorsa OutOfMemory yaÅŸamamak iÃ§in MemoryStream ile Stream Deserializer yapabilirsiniz. BÃ¶ylelikle bÃ¼yÃ¼k JSON verilerini OutOfMemory hatasÄ± almadan deserialize edebilirsiniz. Async bir method Ã§aÄŸÄ±rdÄ±ÄŸÄ±nÄ±z takdirde retun Task.CompletedTask dÃ¶nmenize de gerek kalmayacaktÄ±r.

### Service Bus Queue OluÅŸturma

Azure Portal Ã¼zerinden Queue oluÅŸturalÄ±m ve ConnectionString alalÄ±m. BÃ¶ylelikle uygulamamÄ±zÄ± Ã§alÄ±ÅŸmasÄ± iÃ§in gereken son aÅŸamayÄ± tamamlamÄ±ÅŸ olacaÄŸÄ±z.

![alt text](https://miro.medium.com/max/1400/1*6cRLuqBpYG4TtrpGBK2yfg.png ".NET Core Hosted Service ile Azure Service Bus KullanÄ±mÄ±")

Burada ServiceBus Ã¼zerinde built-in gelen birtakÄ±m Ã¶zellikler bulunmaktadÄ±r. Benim sevdiÄŸim en gÃ¼zel Ã¶zelliklerden birisi duplication detection Ã¶zelliÄŸidir. Bu Ã¶zelliÄŸi enable ettiÄŸinizde belirli bir aralÄ±ktaki tekrarlanan mesajlarÄ± engelleyebilirsiniz. BÃ¶ylelikle sisteminizin daha stabil olmasÄ±nÄ± saÄŸlarsÄ±nÄ±z. Bir diÄŸer Ã¶zelliÄŸi ise session Ã¶zelliÄŸidir. Burada ise queue iÃ§erisindeki mesajlarÄ±n atÄ±ldÄ±ÄŸÄ± sÄ±rada consume edilmesinin garantisini vermektedir. First In First Out (FIFO) olarak Ã§alÄ±ÅŸan ve sizin attÄ±ÄŸÄ±nÄ±z sÄ±rada Ã§alÄ±ÅŸmasÄ±nÄ± garanti etmektedir. BÃ¶ylelikle session oluÅŸturarak farklÄ± bir transactional yapÄ± kullanabilirsiniz. Bu Ã¶zellik distributed sistemler iÃ§in tehlikelidir. Bu yÃ¼zden mimarinizi bunun Ã¼zerine kurmamanÄ±zÄ± tavsiye edebilirim. Expire olan message larÄ± otomatik olarak dead letter a atabilir ve message kaybetmenizi minimum a dÃ¼ÅŸÃ¼rebilirsiniz. Buradaki dikkat edebileceÄŸiniz bir diÄŸer Ã¶zellik ise Lock Duration olacaktÄ±r. Ack gÃ¶ndermediÄŸiniz mesajlar iÃ§in belirlediÄŸiniz bir lock time yaratÄ±yor ve bu sÃ¼re iÃ§erisinde baÅŸka consumer bu mesajÄ± consume edemiyor. Bu sÃ¼reyi aÅŸtÄ±ÄŸÄ±nda ve Ack almadÄ±ysa baÅŸka consumerlar tarafÄ±ndan consume edilebilmektedir.

![alt text](https://miro.medium.com/max/1204/1*9fUYexBp1FE6_dWQBPJcTg.png ".NET Core Hosted Service ile Azure Service Bus KullanÄ±mÄ±")

OluÅŸturduÄŸumuz Queue Ã¼zerinden Shared access policies bÃ¶lÃ¼mÃ¼nden Policy yaratalÄ±m. Burada oluÅŸturacaÄŸÄ±mÄ±z Policy, tam olarak ne yapacaÄŸÄ±nÄ± belirtmekteyiz. Consumer iÃ§in Listen Policy, Producer iÃ§in ise Send Policy tanÄ±mlayarak iki farklÄ± ConnectionString yaratabilir, bÃ¶ylelikle Security aÃ§Ä±sÄ±ndan ortamlarÄ±nÄ±zÄ±n gÃ¼venliÄŸini saÄŸlayabilirsiniz. Bu Ã¶rneÄŸimizde hem Consumer hem de producer olarak yapacaÄŸÄ±mÄ±z iÃ§in Manage i tercih ediyoruz.

![alt text](https://miro.medium.com/max/1196/1*qFkPBXqnmgqAEgs5a7fKGQ.png ".NET Core Hosted Service ile Azure Service Bus KullanÄ±mÄ±")

ConnectionString iÃ§erisindeki EntityPath i silebilirsiniz. UygulamamÄ±z iÃ§erisinde zaten QueueName olarak vereceÄŸimiz iÃ§in ConnectionString e eklememize gerek yok.

### Consumer UygulamasÄ±nÄ± Test Edelim

Gerekli olan tÃ¼m aÅŸamalarÄ± tamamladÄ±ÄŸÄ±mÄ±za gÃ¶re artÄ±k Ã§alÄ±ÅŸtÄ±rabiliriz. UygulamamÄ±za Environment Variable ya da Command-line Ã¼zerinden ConnectionString ve QueueName i iletebiliriz. Ben Command-line Ã¼zerinden tercih edeceÄŸim

```cs
    dotnet run /"ServiceBusConnectionString={ServiceBusConnectionString}" /"ServiceBusQueueName={ServiceBusQueueName}"
```

YukarÄ±daki komut iÃ§erisinde {ServiceBusConnectionString} ve {ServiceBusQueueName} kendi oluÅŸturduÄŸunuz ConnectionString ve QueueName ile deÄŸiÅŸtiriniz.

![alt text](https://miro.medium.com/max/1400/1*6jDoAluS_GN_nSp0yWpyyA.png ".NET Core Hosted Service ile Azure Service Bus KullanÄ±mÄ±")

ArdÄ±ndan test iÃ§in Azure Portal Ã¼zerinden oluÅŸturduÄŸunuz Queue iÃ§erisinde Service Bus Explorer ile mesaj gÃ¶nderebilirsiniz.

![alt text](https://miro.medium.com/max/1400/1*xB5H6KL7WHO7g2-MebL0_A.png ".NET Core Hosted Service ile Azure Service Bus KullanÄ±mÄ±")

GÃ¶rdÃ¼ÄŸÃ¼nÃ¼z gibi gÃ¶nderdiÄŸimiz message uygulamamÄ±za iletildi ve log olarak yazdÄ±. Consumer bÃ¶lÃ¼mÃ¼mÃ¼z baÅŸarÄ±lÄ± bir ÅŸekilde Ã§alÄ±ÅŸtÄ±.

## Producer UygulamasÄ± GeliÅŸtirme

Consumer ile Producer arasÄ±ndaki en bÃ¼yÃ¼k farklardan birisi, RegisterMessageHandler Ä± Ã§aÄŸÄ±rmanÄ±za gerek yoktur. YapmanÄ±z gereken IQueueClient Ä± mesajÄ± gÃ¶ndermek istediÄŸiniz class iÃ§erisine inject ettikten sonra aÅŸaÄŸÄ±daki gibi Ã¶rnek bir kod Ã§alÄ±ÅŸtÄ±rmanÄ±z yeterli olacaktÄ±r. Ã–rnek olarak consume ettiÄŸim mesajÄ± tekrar aynÄ± queue ya bÄ±rakalÄ±m.

```cs
        private async Task OnProcess(Message message, CancellationToken cancellationToken)
        {
            var json = Encoding.UTF8.GetString(message.Body);
            _logger.LogInformation($"Queue Message: {json}");

            var data = JsonSerializer.Deserialize<object>(json);

            if (data != null)
            {
                var producerData = new
                {
                    message = "Hello Service Bus from Producer"
                };

                string producerJson = JsonSerializer.Serialize(producerData);

                await _queueClient.SendAsync(new Message(Encoding.UTF8.GetBytes(producerJson)));
            }
        }
```

Gelen mesaj boÅŸ deÄŸilse producerData adÄ±nda bir obje oluÅŸturuluyor ve bu JSON string olarak serialize ediliyor ve ardÄ±ndan byte array e Ã§evirilerek Message class Ä±na verilerek gÃ¶nderiliyor. Bu message class Ä± iÃ§erisinde custom properties ler de gÃ¶nderebilirsiniz. Ã–rneÄŸin kaÃ§ kez retry ettiÄŸi, veya birtakÄ±m metadata lar olabilir (CorrelationId, Sender Agent Name vs.) SendAsync ile birden fazla mesajÄ± aynÄ± zamanda da gÃ¶nderebilirsiniz. List olarak da kabul etmektedir. Burada da OutOfMemory yaÅŸamamak adÄ±na Serialize iÅŸlemini de Stream olarak uygulayabilirsiniz

## SonlandÄ±ralÄ±m

Bu yazÄ±mÄ±zda temel olarak Azure Service Bus kullanÄ±mÄ±nÄ± ve bunu .NET Core uygulamalarÄ±nda en ideal yÃ¶ntem olan HostedService ile nasÄ±l Consumer veya Producer olarak saÄŸladÄ±ÄŸÄ±mÄ±zÄ±, Dependency Injection uygulayarak temiz bir yapÄ±da kurduk. Unit Test yazacaÄŸÄ±nÄ±z ve QueueClient Ä± kolayca Mocklayabileceksiniz. BÃ¶ylelikle 3rd party integration larÄ±nÄ±zÄ± da kolayca Mock layarak business logic testlerinizi yazabilirsiniz.

Twitter ve Github Ã¼zerinden takip etmeyi unutmuyoruzdur umarÄ±m ğŸ˜‡ğŸ˜‡ğŸ˜‡

ArtÄ±k Youtube Ã¼zerinden de yayÄ±nda olacaÄŸÄ±m. KanalÄ±ma abone olmanÄ±zÄ± ve bildirimleri aÃ§arak en gÃ¼ncel teknolojileri nasÄ±l uyguladÄ±ÄŸÄ±mÄ± takip edebilirsiniz ğŸ™ğŸ™ğŸ™

Ä°yi okumalar :) ğŸ‰ğŸ¤ğŸ»

</MarkdownWrapper>
